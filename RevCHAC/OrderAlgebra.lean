import RevCHAC

set_option linter.unusedSectionVars false

/-!
# OrderAlgebra: Boolean Algebra on Vectorial Order

This module formalizes the interaction between:
1.  **Vectorial Order**: A partial order on a set of profiles `P` (representing the geometric/obstructional state).
2.  **Boolean Algebra**: A subalgebra of the power set of `P`, generated by structural predicates.
3.  **Dissociation**: Formal theorems showing that specific predicates (like `CH_ok`, `AC_ok`) are invariant under changes in orthogonal directions of the vectorial order.

## Integration with RevCHAC

This module provides the algebraic framework for understanding why `CH` and `AC` predicates
are "dissociated" — they depend on orthogonal components of the profile space:
- `CH_ok` depends only on the "Cut" component (program structure)
- `AC_ok` depends only on the "Bit" component (halting behavior)

This formalizes the geometric intuition behind the Rev-CH-AC separation.
-/

namespace LogicDissoc
namespace Boole

open Set

variable {P : Type*}

/-! ### 1. Vectorial Order on Profiles -/

/--
A `VectorialOrder` on `P` is simply a partial order structure.
The "vectorial" aspect comes from the specific projections defined in `ProfileComponents`.
-/
class VectorialOrder (P : Type*) extends PartialOrder P

/-! ### 2. Boolean Algebra of Structural Predicates -/

/--
A structural predicate is just a subset of profiles.
-/
abbrev StructPred (P : Type*) := Set P

/--
Inductive definition of the subalgebra generated by a family `F` of predicates.
`IsGeneratedBy F S` means `S` can be built from elements of `F` using
finite union, finite intersection, and complement.
-/
inductive IsGeneratedBy (F : Set (Set P)) : Set P → Prop where
  | basic {S} : S ∈ F → IsGeneratedBy F S
  | compl {S} : IsGeneratedBy F S → IsGeneratedBy F Sᶜ
  | union {S T} : IsGeneratedBy F S → IsGeneratedBy F T → IsGeneratedBy F (S ∪ T)
  | inter {S T} : IsGeneratedBy F S → IsGeneratedBy F T → IsGeneratedBy F (S ∩ T)
  | empty : IsGeneratedBy F ∅
  | univ : IsGeneratedBy F Set.univ

/--
The Boolean algebra generated by `F`.
It is the subtype of `Set P` containing sets generated by `F`.
-/
def GeneratedSubalgebra (F : Set (Set P)) := { S : Set P // IsGeneratedBy F S }

namespace GeneratedSubalgebra

variable {F : Set (Set P)}

/-- Get the underlying set from a GeneratedSubalgebra element. -/
def toSet (x : GeneratedSubalgebra F) : Set P := x.val

/-- Union of two generated sets. -/
def union (S T : GeneratedSubalgebra F) : GeneratedSubalgebra F :=
  ⟨S.val ∪ T.val, IsGeneratedBy.union S.property T.property⟩

/-- Intersection of two generated sets. -/
def inter (S T : GeneratedSubalgebra F) : GeneratedSubalgebra F :=
  ⟨S.val ∩ T.val, IsGeneratedBy.inter S.property T.property⟩

/-- Complement of a generated set. -/
def compl (S : GeneratedSubalgebra F) : GeneratedSubalgebra F :=
  ⟨S.valᶜ, IsGeneratedBy.compl S.property⟩

/-- The empty set. -/
def bot : GeneratedSubalgebra F := ⟨∅, IsGeneratedBy.empty⟩

/-- The universal set. -/
def top : GeneratedSubalgebra F := ⟨Set.univ, IsGeneratedBy.univ⟩

/-- Subset ordering. -/
def le (S T : GeneratedSubalgebra F) : Prop := S.val ⊆ T.val

/-- Boolean complement law: S ∩ Sᶜ = ∅. -/
theorem inter_compl_eq_bot (S : GeneratedSubalgebra F) : inter S (compl S) = bot := by
  apply Subtype.ext
  simp only [inter, compl, bot]
  ext x
  simp [Set.mem_inter_iff, Set.mem_compl_iff]

/-- Boolean complement law: S ∪ Sᶜ = univ. -/
theorem union_compl_eq_top (S : GeneratedSubalgebra F) : union S (compl S) = top := by
  apply Subtype.ext
  simp only [union, compl, top]
  ext x
  simp [Set.mem_union, Set.mem_compl_iff, em]

end GeneratedSubalgebra

/-! ### 3. Structural Components and Projections -/

variable (CutProfile BitProfile RankProfile : Type*)

/--
We assume `P` has projections to various components.

In the context of RevCHAC:
- `CutProfile`: The structural component (e.g., program length or encoding)
- `BitProfile`: The halting component (e.g., halting status)
- `RankProfile`: The ordering component (e.g., step count, delta)
-/
class ProfileComponents (P : Type*) (CutProfile BitProfile RankProfile : outParam Type*) where
  cut  : P → CutProfile
  bit  : P → BitProfile
  rank : P → RankProfile

variable [VectorialOrder P]
variable {CutProfile BitProfile RankProfile : Type*}
variable [ProfileComponents P CutProfile BitProfile RankProfile]

/-! ### 4. "Depends only on Cut / Bit" -/

/--
Definition of "depending only on Cut".

A predicate `S` depends only on Cut if for all `x, y`,
`x.cut = y.cut` implies `x ∈ S ↔ y ∈ S`.

In RevCHAC context: If two programs have the same structure (length/encoding),
they have the same CH status.
-/
def DependsOnlyOnCut (S : Set P) : Prop :=
  ∀ x y : P,
    ProfileComponents.cut (P := P) (RankProfile := RankProfile) x =
    ProfileComponents.cut (P := P) (RankProfile := RankProfile) y →
    (x ∈ S ↔ y ∈ S)

/--
Definition of "depending only on Bit".

A predicate `S` depends only on Bit if for all `x, y`,
`x.bit = y.bit` implies `x ∈ S ↔ y ∈ S`.

In RevCHAC context: If two programs have the same halting behavior,
they have the same AC status.
-/
def DependsOnlyOnBit (S : Set P) : Prop :=
  ∀ x y : P,
    ProfileComponents.bit (P := P) (RankProfile := RankProfile) x =
    ProfileComponents.bit (P := P) (RankProfile := RankProfile) y →
    (x ∈ S ↔ y ∈ S)

/-! ### 5. CH and AC Predicates + Specs -/

/--
Abstract specification for CH and AC validity on profiles.

On top of saying that `CH_ok` and `AC_ok` live in the generated
subalgebra `GeneratedSubalgebra F`, we require:

* `CH_depends` : CH depends only on Cut,
* `AC_depends` : AC depends only on Bit.

This captures the **dissociation** between CH and AC:
they are invariant under changes in orthogonal directions.
-/
class LogicSpecs (P : Type*) (F : Set (Set P))
    (CutProfile BitProfile RankProfile : outParam Type*)
    [ProfileComponents P CutProfile BitProfile RankProfile] where
  CH_ok      : GeneratedSubalgebra F
  AC_ok      : GeneratedSubalgebra F
  CH_depends :
    DependsOnlyOnCut (P := P) (CutProfile := CutProfile)
                     (BitProfile := BitProfile) (RankProfile := RankProfile)
      CH_ok.val
  AC_depends :
    DependsOnlyOnBit (P := P) (CutProfile := CutProfile)
                     (BitProfile := BitProfile) (RankProfile := RankProfile)
      AC_ok.val

variable {F : Set (Set P)}
variable [LogicSpecs P F CutProfile BitProfile RankProfile]

/-! ### 6. Dissociation Theorems (using the specs, no axioms) -/

/--
**Dissociation Theorem (CH)**:

If we change the bits of a profile `x` to get `y` (keeping the Cut identical),
then the validity of `CH_ok` is preserved.

In RevCHAC context: Changing the halting behavior of a program
does not affect whether it satisfies the CH predicate (program structure).
-/
theorem CH_invariant_under_bit_change (x y : P)
    (h_same_cut :
      ProfileComponents.cut (P := P) (RankProfile := RankProfile) x =
      ProfileComponents.cut (P := P) (RankProfile := RankProfile) y) :
    x ∈ (LogicSpecs.CH_ok (P := P) (F := F)
            (CutProfile := CutProfile) (BitProfile := BitProfile)
            (RankProfile := RankProfile)).val ↔
    y ∈ (LogicSpecs.CH_ok (P := P) (F := F)
            (CutProfile := CutProfile) (BitProfile := BitProfile)
            (RankProfile := RankProfile)).val := by
  exact (LogicSpecs.CH_depends (P := P) (F := F)
          (CutProfile := CutProfile) (BitProfile := BitProfile)
          (RankProfile := RankProfile)) x y h_same_cut

/--
**Dissociation Theorem (AC)**:

If we change the cuts of a profile `x` to get `y` (keeping the Bit identical),
then the validity of `AC_ok` is preserved.

In RevCHAC context: Changing the structure of a program
does not affect whether it satisfies the AC predicate (halting behavior).
-/
theorem AC_invariant_under_cut_change (x y : P)
    (h_same_bit :
      ProfileComponents.bit (P := P) (RankProfile := RankProfile) x =
      ProfileComponents.bit (P := P) (RankProfile := RankProfile) y) :
    x ∈ (LogicSpecs.AC_ok (P := P) (F := F)
            (CutProfile := CutProfile) (BitProfile := BitProfile)
            (RankProfile := RankProfile)).val ↔
    y ∈ (LogicSpecs.AC_ok (P := P) (F := F)
            (CutProfile := CutProfile) (BitProfile := BitProfile)
            (RankProfile := RankProfile)).val := by
  exact (LogicSpecs.AC_depends (P := P) (F := F)
          (CutProfile := CutProfile) (BitProfile := BitProfile)
          (RankProfile := RankProfile)) x y h_same_bit

/-! ### 7. Interaction with Order (Up-sets and Down-sets) -/

/--
A predicate is an Up-set if it is closed upwards.
-/
def IsUpSet [PartialOrder P] (S : Set P) : Prop :=
  ∀ x y : P, x ∈ S → x ≤ y → y ∈ S

/--
A predicate is a Down-set if it is closed downwards.
-/
def IsDownSet [PartialOrder P] (S : Set P) : Prop :=
  ∀ x y : P, x ∈ S → y ≤ x → y ∈ S

/--
The type of Up-sets in P.
-/
def UpSet (P : Type*) [PartialOrder P] := { S : Set P // IsUpSet S }

/--
The type of Down-sets in P.
-/
def DownSet (P : Type*) [PartialOrder P] := { S : Set P // IsDownSet S }

/--
Union of two Up-sets is an Up-set.
-/
theorem IsUpSet.union [PartialOrder P] {S T : Set P}
    (hS : IsUpSet S) (hT : IsUpSet T) : IsUpSet (S ∪ T) := by
  intro x y hxy hle
  simp only [Set.mem_union] at hxy ⊢
  rcases hxy with hx | hx
  · left; exact hS x y hx hle
  · right; exact hT x y hx hle

/--
Intersection of two Up-sets is an Up-set.
-/
theorem IsUpSet.inter [PartialOrder P] {S T : Set P}
    (hS : IsUpSet S) (hT : IsUpSet T) : IsUpSet (S ∩ T) := by
  intro x y hxy hle
  exact ⟨hS x y hxy.1 hle, hT x y hxy.2 hle⟩

/--
Union of two Down-sets is a Down-set.
-/
theorem IsDownSet.union [PartialOrder P] {S T : Set P}
    (hS : IsDownSet S) (hT : IsDownSet T) : IsDownSet (S ∪ T) := by
  intro x y hxy hle
  simp only [Set.mem_union] at hxy ⊢
  rcases hxy with hx | hx
  · left; exact hS x y hx hle
  · right; exact hT x y hx hle

/--
Intersection of two Down-sets is a Down-set.
-/
theorem IsDownSet.inter [PartialOrder P] {S T : Set P}
    (hS : IsDownSet S) (hT : IsDownSet T) : IsDownSet (S ∩ T) := by
  intro x y hxy hle
  exact ⟨hS x y hxy.1 hle, hT x y hxy.2 hle⟩

/--
The set of profiles with rank at least `r`.
This forms an Up-set in the rank ordering, representing a lower bound constraint on the rank.
-/
def RankAtLeast (r : RankProfile) [PartialOrder RankProfile] : Set P :=
  { x | r ≤ ProfileComponents.rank (CutProfile := CutProfile) (BitProfile := BitProfile) x }

theorem RankAtLeast_is_upset [PartialOrder RankProfile]
    (h_mono : ∀ x y : P, x ≤ y →
      ProfileComponents.rank (CutProfile := CutProfile) (BitProfile := BitProfile) x ≤
      ProfileComponents.rank y)
    (r : RankProfile) :
    IsUpSet (RankAtLeast (P := P) (CutProfile := CutProfile)
               (BitProfile := BitProfile) (RankProfile := RankProfile) r) := by
  intro x y hx hxy
  simp [RankAtLeast] at *
  trans (ProfileComponents.rank (CutProfile := CutProfile) (BitProfile := BitProfile) x)
  · exact hx
  · exact h_mono x y hxy

/-! ### 8. Connection to RevCHAC Concepts -/

/-- A trivial VectorialOrder can be defined on any type with a PartialOrder. -/
instance VectorialOrder.ofPartialOrder [PartialOrder P] : VectorialOrder P where

set_option linter.unusedVariables false in
/--
Combining DependsOnlyOnCut and DependsOnlyOnBit: if both Cut and Bit are preserved,
membership in S is preserved (using either direction).
-/
theorem full_invariance_from_components
    (S : Set P)
    (h_cut : DependsOnlyOnCut (P := P) (CutProfile := CutProfile)
               (BitProfile := BitProfile) (RankProfile := RankProfile) S)
    (h_bit : DependsOnlyOnBit (P := P) (CutProfile := CutProfile)
               (BitProfile := BitProfile) (RankProfile := RankProfile) S)
    (x y : P)
    (h_same_cut :
      ProfileComponents.cut (P := P) (RankProfile := RankProfile) x =
      ProfileComponents.cut (P := P) (RankProfile := RankProfile) y)
    (h_same_bit :
      ProfileComponents.bit (P := P) (RankProfile := RankProfile) x =
      ProfileComponents.bit (P := P) (RankProfile := RankProfile) y) :
    x ∈ S ↔ y ∈ S := by
  exact h_cut x y h_same_cut

end Boole
end LogicDissoc

/-! ## Summary

### What This Module Provides

1. **VectorialOrder**: Abstract partial order structure for profiles
2. **GeneratedSubalgebra**: Boolean algebra generated by structural predicates
3. **ProfileComponents**: Projections to Cut/Bit/Rank components
4. **DependsOnlyOnCut/Bit**: Invariance predicates
5. **LogicSpecs**: Specification that CH/AC depend on orthogonal components
6. **Dissociation Theorems**: CH invariant under Bit changes, AC invariant under Cut changes
7. **UpSet/DownSet**: Closed predicates for order-theoretic properties

### Integration with RevCHAC

To instantiate on the concrete Minsky machine model in `RevCHACOmega.lean`:

```lean
import OrderAlgebra

-- Define ProfileComponents for Program
instance : ProfileComponents Program ℕ Bool ℕ where
  cut := progLength                    -- program structure
  bit := fun p => HaltsProg p          -- halting behavior (semantic)
  rank := fun p => deltaScaled 10 p    -- obstruction measure

-- Then instantiate LogicSpecs with CH_local and Halts_rev
```

### Key Insight

The **dissociation** between CH and AC is geometric:
- CH lives in the "Cut direction" of the profile space
- AC lives in the "Bit direction" of the profile space
- They are orthogonal, hence invariant under changes in the other direction
-/
